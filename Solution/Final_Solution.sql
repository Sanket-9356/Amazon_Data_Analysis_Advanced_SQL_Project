-- Amazon Project - Advanced SQL

CREATE DATABASE IF NOT EXISTS ecommerce_db;
USE ecommerce_db;

-- =========================================================
-- 1. categories
-- =========================================================
CREATE TABLE categories (
    category_id INT PRIMARY KEY,
    category_name VARCHAR(100) NOT NULL
);

-- =========================================================
-- 2. products
-- =========================================================
CREATE TABLE products (
    product_id INT AUTO_INCREMENT PRIMARY KEY,
    product_name VARCHAR(255) NOT NULL,
    price DECIMAL(10,2) NOT NULL,
    cogs DECIMAL(10,2) NOT NULL,
    category_id INT,
    FOREIGN KEY (category_id) REFERENCES categories(category_id)
        ON UPDATE CASCADE ON DELETE SET NULL
);

-- =========================================================
-- 3. customers
-- =========================================================
CREATE TABLE customers (
    customer_id INT PRIMARY KEY,
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100) NOT NULL,
    state VARCHAR(100),
	address VARCHAR (25)
);

-- =========================================================
-- 4. sellers
-- =========================================================
CREATE TABLE sellers (
    seller_id INT AUTO_INCREMENT PRIMARY KEY,
    seller_name VARCHAR(255) NOT NULL,
    origin VARCHAR(100)
);

-- =========================================================
-- 5. orders
-- =========================================================
CREATE TABLE orders (
    order_id INT AUTO_INCREMENT PRIMARY KEY,
    customer_id INT,
    seller_id INT,
    order_date DATE NOT NULL,
    order_status ENUM('Delivered','Shipped','Pending','Cancelled','Returned') DEFAULT 'Pending',
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
        ON UPDATE CASCADE ON DELETE SET NULL,
    FOREIGN KEY (seller_id) REFERENCES sellers(seller_id)
        ON UPDATE CASCADE ON DELETE SET NULL
);

-- =========================================================
-- 6. order_items
-- =========================================================
CREATE TABLE order_items (
    order_item_id INT AUTO_INCREMENT PRIMARY KEY,
    order_id INT NOT NULL,
    product_id INT NOT NULL,
    quantity INT NOT NULL,
    price_per_unit DECIMAL(10,2) NOT NULL,
    FOREIGN KEY (order_id) REFERENCES orders(order_id)
        ON UPDATE CASCADE ON DELETE CASCADE,
    FOREIGN KEY (product_id) REFERENCES products(product_id)
        ON UPDATE CASCADE ON DELETE RESTRICT
);

-- =========================================================
-- 7. inventory
-- =========================================================
CREATE TABLE inventory (
    inventory_id INT AUTO_INCREMENT PRIMARY KEY,
    product_id INT NOT NULL,
    stock INT NOT NULL,
    warehouse VARCHAR(100),
    last_stock_date DATE,
    FOREIGN KEY (product_id) REFERENCES products(product_id)
        ON UPDATE CASCADE ON DELETE CASCADE
);

-- =========================================================
-- 8. payments
-- =========================================================
CREATE TABLE payments (
    payment_id INT AUTO_INCREMENT PRIMARY KEY,
    order_id INT NOT NULL,
    payment_status ENUM('Completed','Pending','Failed','Refunded') DEFAULT 'Pending',
    payment_date DATE,
    FOREIGN KEY (order_id) REFERENCES orders(order_id)
        ON UPDATE CASCADE ON DELETE CASCADE
);

-- =========================================================
-- 9. shipping
-- =========================================================
CREATE TABLE shipping (
    shipping_id INT AUTO_INCREMENT PRIMARY KEY,
    order_id INT NOT NULL,
    shipping_date DATE,
    return_date DATE,
    shipping_provider VARCHAR(100),
    delivery_status ENUM('Delivered','In Transit','Returned','Delayed') DEFAULT 'In Transit',
    FOREIGN KEY (order_id) REFERENCES orders(order_id)
        ON UPDATE CASCADE ON DELETE CASCADE
);


-- Business Problems
-- Advanced Analysis

/*
1. Top Selling Products
Query the top 10 products by total sales value.
Challange : Include product name,total quantity sold and total sales value.
*/

SELECT 
    p.product_name,
    SUM(oi.quantity) AS total_quantity_sold,
    SUM(oi.quantity * oi.price_per_unit) AS total_sales_value
FROM 
    order_items oi
JOIN 
    products p ON oi.product_id = p.product_id
JOIN 
    orders o ON oi.order_id = o.order_id
WHERE 
    o.order_status = 'Delivered'  -- considering only delivered orders for sales
GROUP BY 
    p.product_name
ORDER BY 
    total_sales_value DESC
LIMIT 10;

--

/*
2. Revenue By Category.
Calculate total revenue generated by each product category.
Challange : Include the percentage contribution of each category to total revenue.
*/

SELECT 
    c.category_name,
    SUM(oi.total_sale) AS total_revenue,
    ROUND(
        (SUM(oi.total_sale) / 
         (SELECT SUM(total_sale) FROM order_items)
        ) * 100, 2
    ) AS revenue_percentage
FROM 
    order_items oi
JOIN products p ON oi.product_id = p.product_id
JOIN categories c ON p.category_id = c.category_id
GROUP BY 
    c.category_name
ORDER BY 
    total_revenue DESC;

--

/*
3. Average Order Value (AOV)
Compute the average order value for each customer.
Challenge: Include only customers with more than 5 orders.
*/

SELECT 
    c.customer_id,
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    COUNT(o.order_id) AS total_orders,
    ROUND(SUM(oi.total_sale::NUMERIC)/COUNT(o.order_id)::NUMERIC, 2) AS average_order_value
FROM 
    customers c
JOIN orders o ON c.customer_id = o.customer_id
JOIN order_items oi ON o.order_id = oi.order_id
GROUP BY 
    c.customer_id, customer_name
HAVING 
    COUNT(o.order_id) > 5
ORDER BY 
    average_order_value DESC;

/*
4. Monthly Sales Trend
Query monthly total sales over the past year.
Challenge: Display the sales trend, grouping by month, return current_month sale, last month sale!
*/

SELECT 
    EXTRACT(MONTH FROM o.order_date) AS month,
	EXTRACT(YEAR FROM o.order_date) AS year,
    ROUND(SUM(oi.total_sale)::NUMERIC,2) AS current_month_sales,
    LAG(SUM(oi.total_sale)) OVER (ORDER BY EXTRACT(MONTH FROM o.order_date)) AS last_month_sales
FROM 
    orders o
JOIN order_items oi ON o.order_id = oi.order_id
WHERE 
    o.order_date >= CURRENT_DATE- INTERVAL '1 YEAR'  -- past 12 months
GROUP BY 1,2
ORDER BY 
    month ASC;

SELECT * FROM orders;


/*
5. Customers with no Purchases
Find customers who have registered but nevere placed an order.
Challenge: List customer detail and the time since their registration.
*/

SELECT * 
FROM customers
WHERE customer_id NOT IN (SELECT customer_id 
							FROM orders);
--- OR

SELECT * FROM customers as c
LEFT JOIN orders o
	ON o.customer_id=c.customer_id
WHERE o.customer_id IS NULL

/*
6. Best_Selling Categories by State.
Identify the best-selling product category for each state.
Challenge: Include the total sales for taht category within each state.
*/
SELECT  
	state,
	category_name,
	total_sales
FROM
(SELECT 
	c.state,
	ct.category_name,
	ROUND(SUM(oi.total_sale)::NUMERIC,2) AS total_sales,
	RANK() OVER(PARTITION BY c.state ORDER BY SUM(oi.total_sale) DESC) AS rank
FROM orders o
JOIN customers c
	ON o.customer_id=c.customer_id
JOIN order_items as oi
	ON o.order_id=oi.order_id
JOIN products p
	ON p.product_id=oi.product_id
JOIN categories ct
	ON ct.category_id=p.category_id
GROUP BY 1,2
)
WHERE rank = 1;


/*
7.Customer Lifetime Value(CLTV) .
Calculate the total value of orders placed by each customer over their lifetime.
Challenge: Rank customer based on their CLTV.
*/

SELECT 
    c.customer_id,
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    SUM(oi.total_sale) AS CLTV,
	DENSE_RANK() OVER(ORDER BY SUM(oi.total_sale) DESC ) AS cx_ranking
FROM 
    customers c
JOIN orders o ON c.customer_id = o.customer_id
JOIN order_items oi ON o.order_id = oi.order_id
GROUP BY 
    c.customer_id, customer_name



/*
8.Inventory Stock Alerts.
Query products with stock levels below a certain threshold(e.g.,less than 10 units).
Challenge: Include last restock date and warehouse information.
*/
SELECT 
	i.inventory_id,
	p.product_name,
	i.stock,
	i.last_stock_date,
	i.warehouse
FROM inventory i
JOIN products p
	ON p.product_id=i.product_id
WHERE stock<15;



/*
9.Shipping Delays.
Identify orders where the shippping date is later than 7 days after the order date.
Challenge: Include customer,order details and delivery provider.
*/
SELECT 
    c.*,
	o.*,
	s.shipping_provider
FROM orders o
JOIN shipping s
    ON o.order_id = s.order_id
JOIN customers c
    ON o.customer_id = c.customer_id
WHERE (s.shipping_date - o.order_date) > INTERVAL '7 days';


/*
10.Payment Success Rate.
Calculate the percentage of successful payments across all orders.
Challenge: Include breakdowns by payment status (e.g.failed,pending).
*/

SELECT 
	p.payment_status,
	COUNT(*) AS total_cnt,
	ROUND(COUNT(*)/(SELECT COUNT(*) FROM payments)::NUMERIC*100,2)
FROM orders o
JOIN payments as p
ON o.order_id=p.order_id
GROUP BY 1;


/*
11.Top performing Sellers.
Find thw top 5 sellers based on total sales value.
Challenge: Include successful orders and display their percentage of successful oredrs.
*/
WITH top_sellers
AS
(SELECT 
		s.seller_id,
		s.seller_name,
		SUM(oi.total_sale) AS total_sales
FROM sellers s
JOIN orders o
	ON o.seller_id=s.seller_id
JOIN order_items oi
	ON oi.order_id=o.order_id
GROUP BY 1,2
ORDER BY 3 DESC
LIMIT 5
),
sellers_reports
AS 
(SELECT 
		o.seller_id,
		ts.seller_name,
		o.order_status,
		COUNT(*) AS  total_orders
FROM orders o
JOIN top_sellers AS ts
ON ts.seller_id=o.seller_id
WHERE o.order_status NOT IN ('Shipped','Pending')
GROUP BY 1,2,3
)

SELECT 
	seller_id,
	seller_name,
	SUM(CASE WHEN order_status ='Delivered' THEN total_orders ELSE 0 END)  AS completed_orders,
	SUM(CASE WHEN order_status ='Cancelled' THEN total_orders ELSE 0 END)  AS cancelled_orders,
	SUM(total_orders) AS total_orders,
	ROUND(SUM(CASE WHEN order_status ='Delivered' THEN total_orders ELSE 0 END)::NUMERIC/
	SUM(total_orders)::NUMERIC*100,2) AS successful_order_ratio
FROM sellers_reports
GROUP BY 1,2;



/*
12.Product Profit Margin.
Calculate the profit margin for each product(diference between price and cost of goods sold).
Challenge: Rank products by their profit margin,showing highest to lowest.
*/

SELECT 
	p.product_id,
	product_name,
	SUM(total_sale -(p.cogs*oi.quantity)) /SUM(oi.total_sale)*100 AS profit_margin,
	DENSE_RANK() OVER(ORDER BY SUM(total_sale -(p.cogs*oi.quantity))/SUM(oi.total_sale)*100 DESC) AS product_rank
FROM order_items oi
JOIN products p
	ON p.product_id=oi.product_id
GROUP BY 1,2

/*
13.Most Returned Products.
Query the top 10 products by the number of returns.
Challenge: Display the returns rate as a percentage of total units sold for each product.
*/


SELECT 
	p.product_id,
	product_name,
	COUNT(*) AS total_units_sold,
	SUM(CASE WHEN o.order_status='Cancelled' THEN 1 ELSE 0 END) AS total_cancelled,
	SUM(CASE WHEN o.order_status='Cancelled' THEN 1 ELSE 0 END)::NUMERIC/COUNT(*)::NUMERIC*100 AS cancel_percentage
FROM order_items oi
JOIN products p
	ON p.product_id=oi.product_id
JOIN orders o
	 ON o.order_id=oi.order_id
GROUP BY 1,2
ORDER BY 5 DESC;


/*
15.Inactive Sellers.
Identify sellers who haven't made any sales in the last  6 months.
Challenge: Show the last date and total sales from tose sellers.
*/


WITH ctel -- as these sellers has not done any sale in the last 3 month
AS
(SELECT * FROM sellers
WHERE seller_id NOT IN (SELECT seller_id FROM orders WHERE order_date>= CURRENT_DATE - INTERVAL '6 MONTH')
)
SELECT 
	o.seller_id,
	MAX(o.order_date) AS last_sale,
	MAX(oi.total_sale ) AS last_sale_amount
FROM orders AS o
JOIN ctel
	ON ctel.seller_id=o.seller_id
JOIN order_items oi
	ON oi.order_id=o.order_id
GROUP BY 1;


/*
16.Identify customers into returning or new.
If the customer has done more than 5 returns categories them as returning oterwise new.
Challenge: List customer id ,name,total orders,total returns.
*/

SELECT 
	c_full_name AS customers,
	total_orders,
	total_cancels,
CASE 
	WHEN total_cancels > 5 THEN 'Cancelling_customers' ELSE 'New'
END AS c_category
FROM
(
SELECT 
	CONCAT(c.first_name,' ',c.last_name) AS c_full_name,
	COUNT(o.order_id) AS total_orders,
	SUM(CASE WHEN o.order_status='Cancelled' THEN 1 ELSE 0 END) AS total_cancels
FROM orders AS o
JOIN customers AS c
	ON 	c.customer_id=o.customer_id
JOIN order_items oi
	ON oi.order_id=o.order_id
GROUP BY 1
)


/*
17.Top 5 customers by Orders in Each Stage.
Identify the top 5 customers with the highest number of orders for each state.
Challenge: Include the number of orders and total sales for each customer.
*/

SELECT * 
FROM 
(
SELECT 
	c.state,
	CONCAT(c.first_name,' ',c.last_name) AS c_full_name,
	COUNT(o.order_id) AS total_orders,
	SUM(oi.total_sale) AS total_sales,
	DENSE_RANK() OVER(PARTITION BY c.state ORDER BY COUNT(o.order_id) DESC) AS rank
FROM orders AS o
JOIN customers AS c
	ON 	c.customer_id=o.customer_id
JOIN order_items oi
	ON oi.order_id=o.order_id
GROUP BY 1,2
)
WHERE rank<=5;



/*
18.Revenue by Shipping Provider.
Calculate the total revenue handled by each shipping provider.
Challenge: Include the total number of orders handled and the average delivery time for each provider.
*/

SELECT 
	s.shipping_provider,
	COUNT(o.order_id) AS order_handled,
	SUM(oi.total_sale) AS total_sales,
	COALESCE(AVG(s.return_date - s.shipping_date),0) AS average_days
FROM orders AS o
JOIN shipping AS s
	ON 	s.order_id=o.order_id
JOIN order_items oi
	ON  oi.order_id=o.order_id
GROUP BY 1 ;


/*
19.Top 10 product with highest decreasing revenue ratio compare to last year(2024) and current_year(2025).
Challenge: Return product_id,product_name,category name,2022 revenue and 2023 revenue decrease ratio at end round result.
Note : Decrease ratio = cr-ls/ls*100	(cs=current_year , ls=last_year)
*/

WITH last_year_sale
AS
(
SELECT 
	p.product_id,
	p.product_name,
	SUM(oi.total_sale) AS revenue
FROM orders AS o
JOIN order_items AS oi
	ON o.order_id=oi.order_id
JOIN products p
	ON p.product_id=oi.product_id
WHERE EXTRACT(YEAR FROM o.order_date)=2024
GROUP BY 1,2
),

current_year_sale
AS
(
SELECT 
	p.product_id,
	p.product_name,
	SUM(oi.total_sale) AS revenue
FROM orders AS o
JOIN order_items AS oi
	ON o.order_id=oi.order_id
JOIN products p
	ON p.product_id=oi.product_id
WHERE EXTRACT(YEAR FROM o.order_date)=2025
GROUP BY 1,2
) 

SELECT 
	cs.product_id,
	cs.revenue AS current_year_revenue,
	ls.revenue AS last_year_revenue,
	ls.revenue - cs.revenue AS rev_diff,
	ROUND(((cs.revenue - ls.revenue)/ls.revenue*100)::NUMERIC,2) AS revenue_dec_ratio
FROM last_year_sale AS ls
JOIN current_year_sale as cs
ON ls.product_id=cs.product_id
WHERE ls.revenue > cs.revenue
ORDER BY 5 
LIMIT 10;



-- Stored Procedure

/*
20.“Create a stored procedure (or function) so that as soon as a product is sold, 
the same quantity should be reduced from the inventory table. After adding any sales record,
it should update the stock in the inventory table based on the product and quantity purchased.”
*/


CREATE OR REPLACE PROCEDURE update_inventory(
    p_order_id INT,
    p_customer_id INT,
    p_seller_id INT,
    p_order_item_id INT,
    p_product_id INT,
    p_quantity INT
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_stock INT;
    v_price NUMERIC(10,2);
    v_product VARCHAR(300);
BEGIN
    -- Fetch product details
    SELECT product_name, price
    INTO v_product, v_price
    FROM products
    WHERE product_id = p_product_id;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'Product id % does not exist', p_product_id;
    END IF;

    -- Check inventory stock
    SELECT stock INTO v_stock
    FROM inventory
    WHERE product_id = p_product_id;

    IF v_stock IS NULL THEN
        RAISE EXCEPTION 'Product % not found in inventory', p_product_id;
    ELSIF v_stock < p_quantity THEN
        RAISE EXCEPTION 'Not enough stock for product %', v_product;
    ELSE
        -- Insert order
        INSERT INTO orders(order_id, order_date, customer_id, seller_id)
        VALUES (p_order_id, CURRENT_DATE, p_customer_id, p_seller_id);

        -- Insert order item
        INSERT INTO order_items(order_item_id, order_id, product_id, quantity, price_per_unit, total_sale)
        VALUES (p_order_item_id, p_order_id, p_product_id, p_quantity, v_price, v_price * p_quantity);

        -- Update inventory
        UPDATE inventory
        SET stock = stock - p_quantity
        WHERE product_id = p_product_id;

        RAISE NOTICE 'Product "%" sold successfully. Inventory updated.', v_product;
    END IF;
END;
$$;


-- Calling the Procedure

CALL update_inventory(
    26002,    -- p_order_id
    2,       -- p_customer_id
    5,      -- p_seller_id
    26003,     -- p_order_item_id
    47,       -- p_product_id
    500      -- p_quantity
);

SELECT * FROM inventory
WHERE product_id=47;
